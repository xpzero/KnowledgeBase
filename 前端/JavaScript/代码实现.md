# 代码实现

## bind实现

> **`bind()`** 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

```js
function mBind () {
    
}
```

## apply实现

## call实现

## 深拷贝

## 浅拷贝

## 防抖

短时间内多次触发同一函数，只执行最后一次/只在开始执行。[一只小猫冷的发抖，稍用力按住它，它就不抖了。可以在它抖一次之后按住，也可以在它抖了很久之后按住]

### 普通实现

```js
/**
 * 普通实现
 * 函数防抖[函数高频率被调用只执行第一次/最后一次]
 * @param {Function} func 需要防抖的函数
 * @param {Number} [duration=1000] 防抖时长[多长时间内的点击需要防抖]
 */
function debounce (func, duration = 1000) {
    let timer = null;
    return function () {
        /*if (timer!== null)*/ clearTimeout(timer);
        timer = setTimeout(func, delay);
    }
}
```

### 立即执行实现

```js
/**
 * 函数防抖
 * @param {Function} func 需要防抖的函数
 * @param {Number} [duration=1000] 防抖持续时长
 * @param {Boolean} [immediate=true] 是否立即执行 
 * @returns 
 */
function debounce(func, first = true, duration = 1000){
    // 声明一个空的定时器id，为防抖做准备
	let timer = null;
	// 返回函数是因为这个防抖函数可能会被绑定/赋值给其他函数使用
	return function (...args) {
		const context = this;
		const firstExecute = first && !timer;
		firstExecute && func.apply(context, args);
		// 不用判断timer是否存在，传入一个错误的 ID 给 clearTimeout()不会有任何影响；也不会抛出异常。
		clearTimeout(timer);
		timer = setTimeout(() => {
			// 非首次防抖则调用这个函数
			!first && func.apply(this, args);
			// 为下一次防抖做准备
			timer = null;
		}, duration);
	};
}
```

## 节流

一段时间内只允许函数执行一次[打游戏时的技能冷却，技能在释放一次之后只能在指定时长之后才可以再次释放]

### 时间戳实现

会在第一次触发事件时立即执行[给事件绑定函数与真正触发事件的间隔一般大于delay]，以后每过delay秒执行一次，且最后一次触发不会被执行。

```js
/**
 * 函数节流
 * @param {Function} func 需要节流的函数
 * @param {Number} [duration=16] 节流持续的时长
 */
function throttle(func, duration = 1000) {// 时间戳实现
    let prev = Date.now();
    return function (...args) {
        const now = Date.now();
        if (now - prev > duration) {
            func.apply(this, args);
            prev = Date.now();
        }
    }
}
```

### 定时器实现

第一次触发不会执行，而是在delay秒后执行，当最后一次停止触发后，还会再执行一次函数。

```js
function throttle(func, duration = 1000) {// 定时器实现
    let timer = null;
    return function (...args) {
        if (!timer) {
            timer = setTimeout(() => {
                func.apply(this, args);
                timer = null;
            }, duration);
        }
    }
}
```
### 时间戳 + 定时器实现

### 可取消的时间戳+定时器实现