# 每天一个知识点

## 函数柯里化[Currying]

> https://www.html.cn/web/javascript/14215.html
>
> https://www.jianshu.com/p/5e1899fe7d6b

### What

> <span style='color: red;font-weight: bold;'>柯里化是</span>把接收多个参数的函数变换成接收单个参数(最初函数的第一个参数)的函数，且<span style='color: blue;font-weight: bold;'>返回</span>**可以接收其余参数并返回结果的<span style='color: blue;font-weight: bold;'>新函数</span>**的<span style='color:red; font-weight: bold;'>技术</span>

### How

#### 示例

```js
// 普通函数
function add (x, y) {
    return x + y;
}

// 柯里化后
let curryingAdd = function (x) {
    return function (y) {
        return x + y;
    }
}

// 使用
let increment = curryingAdd(1);

let addTen = curryingAdd(10);

console.log(increment(2));// 3
console.log(addTen(2));// 12
```

#### 实现

```js
// 通用封装，这样返回的话其实只能多扩展一个参数，不支持currying(a)(b)(c)
let currying = function (fn, ...args) {
    return function (...newArgs) {
    	return fn.apply(this, [...args, ...newArgs]);
    }
}

// 支持多参数调用
function progressCurrying(fn, ...args) {
    const len = fn.length; // 函数的形参个数
    return function (...newArgs) {
        newArgs = [...newArgs, ...args];
        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
        if (newArgs.length < len) {
            return progressCurrying.apply(this, fn, newArgs);
        }
        return fn.apply(this, newArgs);
    }
}

// 使用
let add = function (x) {
	return function (y) {
		return x + y;
	};
};
let add2 = progressCurrying(add);
console.log(add2(1)(2));
```

### Why

#### 一、参数复用

```js
// 正常正则验证字符串 reg.test(txt);

// 函数封装后
function check (reg, txt) {
    return reg.test(txt);
}
check(/\d+/g, 'test');  // false
check(/[a-z]+/g, 'test');  // true

// Currying后
function curryingCheck (reg) {
    return function (txt) {
        return reg.test(txt);
    }
}

let hasNumber = curryingCheck(/\d+/g);
let hasLetter = curryingCheck(/[a-z]+/g);

console.log(hasNumber('test1')); // true
console.log(hasNumber('testtest')); // false
console.log(hasLetter('121212')); // false
```

#### 二、提前确认

```js
let on = function (element, event, handler) {
    if (document.addEventListener) {
        if (element && event && handler) {
            element.addEventListener(event, handler, false);
        }
    } else {
        if (element && event && handler) {
            element.attachEvent('on' + event, handler);
        }
    }
}

// Currying后
let on = (function () {
    if (document.addEventListener) {
        return function (element, event, handler) {
            if (element && event && handler) {
                element.addEventListener(event, handler, false);
            }
        }
    } else {
        return function (element, event, handler) {
            if (element && event && handler) {
                element.attachEvent('on' + event, hanndler);
            }
        }
    }
})();

// 另一种写法
let on = function (isSupport, element, event, handler) {
    isSupport = isSupport || document.addEventListener;
    if (isSupport) {
        return element.addEventListener(event, handler, false);
    } else {
        return element.attachEvent('on' + event, handler);
    }
}
```

#### 三、延迟计算/运行

```js
Function.prototype.bind = function (thisArg, ...args) {
    return function () {
        return this.apply(thisArg, args);
    }
}
```

### 一道面试题

> ```
> // 实现一个add方法，使计算结果能够满足如下预期：
> add(1)(2)(3) = 6;
> add(1, 2, 3)(4) = 10;
> add(1)(2)(3)(4)(5) = 15;
> ```

```js
function add (...args) {
	// 1. 使用闭包特性收集参数
	let _adder = function (...newArgs) {
		args.push(...newArgs);
		return _adder;
	}
	// 2. 计算得出最后结果
	_adder.toString = function () {
		return args.reduce((a, b) => a + b);
	}
	// 3. 返回一个函数[柯里化]
	return _adder;
}

总结：
	1. 柯里化返回新函数
    2. 收集参数
    3. 上面两步同时进行，需要获取结果的时候使用收集到的参数计算结果
```

## 原型

> https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes

> JavaScript 常被描述为一种**基于原型的语言 (prototype-based language)**——每个对象拥有一个**原型对象**，<span style='color: red; font-weight: bold;'>对象以其原型为模板、从原型继承方法和属性</span>。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。
>
> 准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的`prototype`属性上，而非对象实例本身。
>
> 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。

### `prototype`属性

只有<span style='color: blue; font-weight: bold;'>函数</span>拥有`prototype`属性。

### `__proto__`属性

只有<span style='color: blue; font-weight: bold;'>对象实例</span>拥有`__proto__`属性。

对象实例就是使用函数创建的对象。

比如:

```js
let a = {};
function B() {}
let xxx = new B();
let arr = [];

// a, xxx, arr都是对象实例
```

### `prototype`和`__proto__`的关系

```js
function A () {}
let a = new A();
console.log(a.__proto__ === A.prototype); // true
A.__proto__ === Function.prototype // true
let arr = [];
console.log(arr.__proto__ === Array.prototype); // true
```

### 为什么这里不输出`undefined`？

```js
function A() {}
console.log(A.__proto__); // 并不输出undefined，说明函数A有`__proto__`属性
```

因为`JavaScript`中的函数也是一个对象，