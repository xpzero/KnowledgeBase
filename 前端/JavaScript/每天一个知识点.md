# 每天一个知识点

## 函数柯里化[Currying]

> https://www.html.cn/web/javascript/14215.html
>
> https://www.jianshu.com/p/5e1899fe7d6b

### What

> <span style='color: red;font-weight: bold;'>柯里化是</span>把接收多个参数的函数变换成接收单个参数(最初函数的第一个参数)的函数，且<span style='color: blue;font-weight: bold;'>返回</span>**可以接收其余参数并返回结果的<span style='color: blue;font-weight: bold;'>新函数</span>**的<span style='color:red; font-weight: bold;'>技术</span>

### How

#### 示例

```js
// 普通函数
function add (x, y) {
    return x + y;
}

// 柯里化后
let curryingAdd = function (x) {
    return function (y) {
        return x + y;
    }
}

// 使用
let increment = curryingAdd(1);

let addTen = curryingAdd(10);

console.log(increment(2));// 3
console.log(addTen(2));// 12
```

#### 实现

```js
// 通用封装
let currying = function (fn, ...args) {
    return function (...newArgs) {
    	return fn.apply(this, [...args, ...newArgs]);
    }
}

// 支持多参数调用
function progressCurrying(fn, ...args) {
    const len = fn.length; // 函数的形参个数
    let mArgs = args || [];
    return function (...newArgs) {
        newArgs = [...newArgs, ...mArgs];
        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
        if (mArgs.length < len) {
            return progressCurrying.apply(this, fn, newArgs);
        }
        return fn.apply(this, newArgs);
    }
}
```

### Why

#### 一、参数复用

```js
// 正常正则验证字符串 reg.test(txt);

// 函数封装后
function check (reg, txt) {
    return reg.test(txt);
}
check(/\d+/g, 'test');  // false
check(/[a-z]+/g, 'test');  // true

// Currying后
function curryingCheck (reg) {
    return function (txt) {
        return reg.test(txt);
    }
}

let hasNumber = curryingCheck(/\d+/g);
let hasLetter = curryingCheck(/[a-z]+/g);

console.log(hasNumber('test1')); // true
console.log(hasNumber('testtest')); // false
console.log(hasLetter('121212')); // false
```

#### 二、提前确认

```js
let on = function (element, event, handler) {
    if (document.addEventListener) {
        if (element && event && handler) {
            element.addEventListener(event, handler, false);
        }
    } else {
        if (element && event && handler) {
            element.attachEvent('on' + event, handler);
        }
    }
}

// Currying后
let on = (function () {
    if (document.addEventListener) {
        return function (element, event, handler) {
            if (element && event && handler) {
                element.addEventListener(event, handler, false);
            }
        }
    } else {
        return function (element, event, handler) {
            if (element && event && handler) {
                element.attachEvent('on' + event, hanndler);
            }
        }
    }
})();

// 另一种写法
let on = function (isSupport, element, event, handler) {
    isSupport = isSupport || document.addEventListener;
    if (isSupport) {
        return element.addEventListener(event, handler, false);
    } else {
        return element.attachEvent('on' + event, handler);
    }
}
```

#### 三、延迟计算/运行

```js
Function.prototype.bind = function (thisArg, ...args) {
    return function () {
        return this.apply(thisArg, args);
    }
}
```

