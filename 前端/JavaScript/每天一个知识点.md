# 每天一个知识点

## 函数柯里化[Currying]

> https://www.html.cn/web/javascript/14215.html
>
> https://www.jianshu.com/p/5e1899fe7d6b

### What

> <span style='color: red;font-weight: bold;'>柯里化是</span>把接收多个参数的函数变换成接收单个参数(最初函数的第一个参数)的函数，且<span style='color: blue;font-weight: bold;'>返回</span>**可以接收其余参数并返回结果的<span style='color: blue;font-weight: bold;'>新函数</span>**的<span style='color:red; font-weight: bold;'>技术</span>

### How

#### 示例

```js
// 普通函数
function add (x, y) {
    return x + y;
}

// 柯里化后
let curryingAdd = function (x) {
    return function (y) {
        return x + y;
    }
}

// 使用
let increment = curryingAdd(1);

let addTen = curryingAdd(10);

console.log(increment(2));// 3
console.log(addTen(2));// 12
```

#### 实现

```js
// 通用封装，这样返回的话其实只能多扩展一个参数，不支持currying(a)(b)(c)
let currying = function (fn, ...args) {
    return function (...newArgs) {
    	return fn.apply(this, [...args, ...newArgs]);
    }
}

// 支持多参数调用
function progressCurrying(fn, ...args) {
    const len = fn.length; // 函数的形参个数
    return function (...newArgs) {
        newArgs = [...newArgs, ...args];
        // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数
        if (newArgs.length < len) {
            return progressCurrying.apply(this, fn, newArgs);
        }
        return fn.apply(this, newArgs);
    }
}

// 使用
let add = function (x) {
	return function (y) {
		return x + y;
	};
};
let add2 = progressCurrying(add);
console.log(add2(1)(2));
```

### Why

#### 一、参数复用

```js
// 正常正则验证字符串 reg.test(txt);

// 函数封装后
function check (reg, txt) {
    return reg.test(txt);
}
check(/\d+/g, 'test');  // false
check(/[a-z]+/g, 'test');  // true

// Currying后
function curryingCheck (reg) {
    return function (txt) {
        return reg.test(txt);
    }
}

let hasNumber = curryingCheck(/\d+/g);
let hasLetter = curryingCheck(/[a-z]+/g);

console.log(hasNumber('test1')); // true
console.log(hasNumber('testtest')); // false
console.log(hasLetter('121212')); // false
```

#### 二、提前确认

```js
let on = function (element, event, handler) {
    if (document.addEventListener) {
        if (element && event && handler) {
            element.addEventListener(event, handler, false);
        }
    } else {
        if (element && event && handler) {
            element.attachEvent('on' + event, handler);
        }
    }
}

// Currying后
let on = (function () {
    if (document.addEventListener) {
        return function (element, event, handler) {
            if (element && event && handler) {
                element.addEventListener(event, handler, false);
            }
        }
    } else {
        return function (element, event, handler) {
            if (element && event && handler) {
                element.attachEvent('on' + event, hanndler);
            }
        }
    }
})();

// 另一种写法
let on = function (isSupport, element, event, handler) {
    isSupport = isSupport || document.addEventListener;
    if (isSupport) {
        return element.addEventListener(event, handler, false);
    } else {
        return element.attachEvent('on' + event, handler);
    }
}
```

#### 三、延迟计算/运行

```js
Function.prototype.bind = function (thisArg, ...args) {
    return function () {
        return this.apply(thisArg, args);
    }
}
```

### 一道面试题

> ```
> // 实现一个add方法，使计算结果能够满足如下预期：
> add(1)(2)(3) = 6;
> add(1, 2, 3)(4) = 10;
> add(1)(2)(3)(4)(5) = 15;
> ```

```js
function add (...args) {
	// 1. 使用闭包特性收集参数
	let _adder = function (...newArgs) {
		args.push(...newArgs);
		return _adder;
	}
	// 2. 计算得出最后结果
	_adder.toString = function () {
		return args.reduce((a, b) => a + b);
	}
	// 3. 返回一个函数[柯里化]
	return _adder;
}

总结：
	1. 柯里化返回新函数
    2. 收集参数
    3. 上面两步同时进行，需要获取结果的时候使用收集到的参数计算结果
```

## 原型

> https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes
>
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object
>
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function

> JavaScript 常被描述为一种**基于原型的语言 (prototype-based language)**——每个对象拥有一个**原型对象**，<span style='color: red; font-weight: bold;'>对象以其原型为模板、从原型继承方法和属性</span>。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。
>
> 准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的`prototype`属性上，而非对象实例本身。
>
> 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。

### `prototype`

指向构造函数的原型

只有<span style='color: blue; font-weight: bold;'>函数</span>拥有`prototype`

### `constructor`	

### `__proto__`

指向对象实例的构造函数的原型

只有<span style='color: blue; font-weight: bold;'>对象实例</span>拥有`__proto__`。**对象实例就是使用函数创建的对象。**

比如:

```js
let a = {};
function B() {}
let xxx = new B();
let arr = [];

// a, xxx, arr都是对象实例
```

### `prototype`和`__proto__`的关系

```js
function A () {}
let a = new A();
console.log(a.__proto__ === A.prototype); // true
let arr = [];
console.log(arr.__proto__ === Array.prototype); // true
```

### 为什么这里不输出`undefined`？

```js
function A() {}
console.log(A.__proto__); // 并不输出undefined，说明函数A有`__proto__`属性
```

> 在JavaScript中，**<span style='color: red;'>几乎所有的对象都是`Object`类型的实例</span>**，它们都会从`Object.prototype`继承属性和方法。
>
> 每个 <span style='color: red; font-weight: bold;'>JavaScript 函数</span>实际上都**<span style='color: red;'>是</span>**一个 `Function` <span style='color: red; font-weight: bold;'>对象</span>。运行 `(function(){}).constructor === Function // true` 便可以得到这个结论。

由`MDN`的解释可知，在`JavaScript`中函数也是一个`Object`的实例，而对象实例都有`__proto__`属性，所以`A.__proto__`是存在的。

### 原型链

由于知识范围有限，所以`Symbol`和`BigInt`的创建这里没有举例列出。

![Null](每天一个知识点.assets/Null-1612087847529.png)

如果某个属性在当前对象上查找不到，`JavaScript`就会按照`xxx.__proto__.__proto__....`的顺序查找直到找到对应的属性名称/Null为止，找到后即返回，不再向后继续查找。例如

```js
Object.prototype.mName = 'Object';
Object.prototype.xxx = 'xxx';
Number.prototype.mName = 'mNmaee os Number';
Number.prototype.mFunc = 'suio Func';
let count = 123;
// 因为count是数字类型，所以这里的属性不能被添加到count上
count.mName = '123';
console.log(count); // 123
// 在Number的原型上定义的
console.log(count.mName); // mNmaee os Number
// 在Number的原型上定义的
console.log(count.mFunc); // suio Func
// 在Object的原型上定义的[原型链：count.__proto__ => Number.prototype => Number.prototype.__proto__ => Object.prototype]
console.log(count.xxx); // xxx

let obj = {
    mName: 'obj',
    mFunc () {
        console.log('mFunc');
    }
};
console.log(obj); // {mName: "obj", mFunc: ƒ}
// obj对象上定义的
console.log(obj.mName); // obj
// obj对象上定义的
console.log(obj.mFunc); // ƒ mFunc () {console.log('mFunc');}
// Object原型上定义的[原型链：obj.__proto__ => Object.prototype]
console.log(obj.xxx); // xxx
```

